// Generated by CoffeeScript 1.9.0
(function() {
  var countLiberties, enemyColor, go_rules, groupPoints, neighboringPoints, tesuji_charm,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (window.tesuji_charm == null) {
    window.tesuji_charm = {};
  }

  tesuji_charm = window.tesuji_charm;

  if (tesuji_charm.go_rules == null) {
    tesuji_charm.go_rules = {};
  }

  go_rules = tesuji_charm.go_rules;

  go_rules.getNewState = function(color, x, y, state) {
    var newState, xg, xn, yg, yn, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    if (state[y][x] !== 'empty') {
      throw Error('illegal move');
    }
    newState = $.extend(true, [], state);
    newState[y][x] = color;
    _ref = neighboringPoints(x, y, newState);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], xn = _ref1[0], yn = _ref1[1];
      if (newState[yn][xn] === enemyColor(color)) {
        if (countLiberties(xn, yn, newState) === 0) {
          _ref2 = groupPoints(xn, yn, newState);
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            _ref3 = _ref2[_j], xg = _ref3[0], yg = _ref3[1];
            newState[yg][xg] = 'empty';
          }
        }
      }
    }
    if (countLiberties(x, y, newState) === 0) {
      throw Error('illegal move');
    }
    return newState;
  };

  neighboringPoints = function(x, y, state) {
    var x0, y0, _i, _len, _ref, _ref1, _results;
    _ref = [[x, y - 1], [x + 1, y], [x, y + 1], [x - 1, y]];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], x0 = _ref1[0], y0 = _ref1[1];
      if (state[y0] !== void 0 && state[y0][x0] !== void 0) {
        _results.push([x0, y0]);
      }
    }
    return _results;
  };

  go_rules._neighbouringPoints = neighboringPoints;

  enemyColor = function(color) {
    switch (color) {
      case 'black':
        return 'white';
      case 'white':
        return 'black';
      default:
        throw Error(color + " has no enemy color");
    }
  };

  countLiberties = function(x, y, state) {
    var liberties, libertiesOfPoint, liberty, xg, yg, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    libertiesOfPoint = function(x, y, state) {
      var color, result, xn, yn, _i, _len, _ref, _ref1;
      color = state[y][x];
      result = [];
      _ref = neighboringPoints(x, y, state);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], xn = _ref1[0], yn = _ref1[1];
        if (state[yn][xn] === 'empty') {
          result.push(xn + " " + yn);
        }
      }
      return result;
    };
    liberties = [];
    _ref = groupPoints(x, y, state);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], xg = _ref1[0], yg = _ref1[1];
      _ref2 = libertiesOfPoint(xg, yg, state);
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        liberty = _ref2[_j];
        if (__indexOf.call(liberties, liberty) < 0) {
          liberties.push(liberty);
        }
      }
    }
    return liberties.length;
  };

  go_rules._countLiberties = countLiberties;

  groupPoints = function(x, y, state) {
    var groupPointsInternal;
    groupPointsInternal = function(x, y, state, seen) {
      var color, result, xn, yn, _i, _len, _ref, _ref1, _ref2;
      color = state[y][x];
      result = [[x, y]];
      _ref = neighboringPoints(x, y, state);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], xn = _ref1[0], yn = _ref1[1];
        if (state[yn][xn] === color && (_ref2 = xn + " " + yn, __indexOf.call(seen, _ref2) < 0)) {
          result = result.concat(groupPointsInternal(xn, yn, state, seen.concat(x + " " + y)));
        }
      }
      return result;
    };
    return groupPointsInternal(x, y, state, []);
  };

  go_rules._groupPoints = groupPoints;

}).call(this);
