// Generated by CoffeeScript 1.9.0
(function() {
  var countLiberties, enemyColor, go_rules, groupPoints, neighboringPoints, tesuji_charm,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (window.tesuji_charm == null) {
    window.tesuji_charm = {};
  }

  tesuji_charm = window.tesuji_charm;

  if (tesuji_charm.go_rules == null) {
    tesuji_charm.go_rules = {};
  }

  go_rules = tesuji_charm.go_rules;

  go_rules.getNewState = function(color, x, y, state) {
    var newState, xg, xn, yg, yn, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    if (state[y][x] !== 'empty') {
      throw Error('illegal move');
    }
    newState = $.extend(true, [], state);
    newState[y][x] = color;
    _ref = neighboringPoints(x, y, newState);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], xn = _ref1[0], yn = _ref1[1];
      if (newState[yn][xn] === enemyColor(color)) {
        if (countLiberties(xn, yn, newState) === 0) {
          _ref2 = groupPoints(xn, yn, newState);
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            _ref3 = _ref2[_j], xg = _ref3[0], yg = _ref3[1];
            newState[yg][xg] = 'empty';
          }
        }
      }
    }
    if (countLiberties(x, y, newState) === 0) {
      throw Error('illegal move');
    }
    return newState;
  };

  go_rules.groupPoints = groupPoints = function(x, y, state, colors) {
    var done, doneState, h, new_, w, x0, xn, y0, yn, _i, _len, _ref, _ref1, _ref2, _ref3;
    if (colors == null) {
      colors = null;
    }
    "Return a list of points in the group around (x, y) from `state`, whether black, white, or empty.";
    if (colors === null) {
      colors = [state[y][x]];
    }
    done = [];
    doneState = (function() {
      var _i, _ref, _results;
      _results = [];
      for (h = _i = 0, _ref = state.length; 0 <= _ref ? _i <= _ref : _i >= _ref; h = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (w = _j = 0, _ref1 = state[0].length; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; w = 0 <= _ref1 ? ++_j : --_j) {
            _results1.push('none');
          }
          return _results1;
        })());
      }
      return _results;
    })();
    new_ = [[x, y]];
    doneState[y][x] = 'new';
    while (true) {
      if (new_.length === 0) {
        return done;
      }
      _ref = new_.pop(), x0 = _ref[0], y0 = _ref[1];
      done.push([x0, y0]);
      doneState[y0][x0] = 'done';
      _ref1 = neighboringPoints(x0, y0, state);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], xn = _ref2[0], yn = _ref2[1];
        if ((_ref3 = state[yn][xn], __indexOf.call(colors, _ref3) >= 0) && doneState[yn][xn] === 'none') {
          new_.push([xn, yn]);
          doneState[yn][xn] = 'new';
        }
      }
    }
  };

  go_rules.boundingColor = function(region, state) {
    "Return the color surrounding the empty region, or 'neither' if boundary is mixed.";
    var point, seen, x, x0, y, y0, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    seen = 'none';
    for (_i = 0, _len = region.length; _i < _len; _i++) {
      _ref = region[_i], x = _ref[0], y = _ref[1];
      _ref1 = neighboringPoints(x, y, state);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        _ref2 = _ref1[_j], x0 = _ref2[0], y0 = _ref2[1];
        point = state[y0][x0];
        if (point === 'empty' || point === 'blackdead' || point === 'whitedead') {
          continue;
        } else if (seen === 'none') {
          seen = point;
          continue;
        } else if (seen !== point) {
          return 'neither';
        }
      }
    }
    if (seen === 'none') {
      seen = 'neither';
    }
    return seen;
  };

  go_rules.neighboringPoints = neighboringPoints = function(x, y, state) {
    var x0, y0, _i, _len, _ref, _ref1, _results;
    _ref = [[x, y - 1], [x + 1, y], [x, y + 1], [x - 1, y]];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], x0 = _ref1[0], y0 = _ref1[1];
      if (state[y0] !== void 0 && state[y0][x0] !== void 0) {
        _results.push([x0, y0]);
      }
    }
    return _results;
  };

  enemyColor = function(color) {
    switch (color) {
      case 'black':
        return 'white';
      case 'white':
        return 'black';
      default:
        throw Error(color + " has no enemy color");
    }
  };

  countLiberties = function(x, y, state) {
    var liberties, libertiesOfPoint, liberty, xg, yg, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    libertiesOfPoint = function(x, y, state) {
      var color, result, xn, yn, _i, _len, _ref, _ref1;
      color = state[y][x];
      result = [];
      _ref = neighboringPoints(x, y, state);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], xn = _ref1[0], yn = _ref1[1];
        if (state[yn][xn] === 'empty') {
          result.push(xn + " " + yn);
        }
      }
      return result;
    };
    liberties = [];
    _ref = groupPoints(x, y, state);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], xg = _ref1[0], yg = _ref1[1];
      _ref2 = libertiesOfPoint(xg, yg, state);
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        liberty = _ref2[_j];
        if (__indexOf.call(liberties, liberty) < 0) {
          liberties.push(liberty);
        }
      }
    }
    return liberties.length;
  };

  go_rules._countLiberties = countLiberties;

}).call(this);
