// Generated by CoffeeScript 1.9.0
(function() {
  var $pointAt, go_rules, imageSrc, isPointBlack, isPointBlackDead, isPointBlackScore, isPointEmpty, isPointWhite, isPointWhiteDead, isPointWhiteScore, setInputSgf;

  $pointAt = function(x, y) {
    return $(".row-" + y + ".col-" + x);
  };

  imageSrc = function($point) {
    return $point.find('img').attr('src');
  };

  isPointEmpty = function($point) {
    return $point.hasClass('nostone');
  };

  isPointBlack = function($point) {
    return $point.hasClass('blackstone');
  };

  isPointWhite = function($point) {
    return $point.hasClass('whitestone');
  };

  isPointBlackScore = function($point) {
    return ($point.hasClass('blackscore')) && (!$point.hasClass('whitescore'));
  };

  isPointWhiteScore = function($point) {
    return ($point.hasClass('whitescore')) && (!$point.hasClass('blackscore'));
  };

  isPointBlackDead = function($point) {
    return $point.hasClass('blackdead');
  };

  isPointWhiteDead = function($point) {
    return $point.hasClass('whitedead');
  };

  module('Persona');

  test('init function sets request and logout callbacks', function() {
    var logoutCalled, mockNavigator, requestCalled, watchCalled;
    requestCalled = false;
    logoutCalled = false;
    watchCalled = false;
    mockNavigator = {
      id: {
        logout: function() {
          return logoutCalled = true;
        },
        request: function() {
          return requestCalled = true;
        },
        watch: function(params) {
          var p_user, t_user;
          p_user = params.loggedInUser;
          t_user = tesuji_charm.currentPersonaEmail;
          ok((t_user === '' && p_user === null) || (t_user !== '' && p_user === t_user), 'navigator.id.watch passed good loggedInUser');
          ok(typeof params.onlogin === 'function', 'navigator.id.watch passed function for onlogin');
          ok(typeof params.onlogout === 'function', 'navigator.id.watch passed function for onlogout');
          return watchCalled = true;
        }
      }
    };
    equal(watchCalled, false);
    tesuji_charm.currentPersonaEmail = '';
    tesuji_charm.persona.initialize(mockNavigator);
    equal(watchCalled, true, 'navigator.id.watch called');
    tesuji_charm.currentPersonaEmail = 'bob@example.com';
    tesuji_charm.persona.initialize(mockNavigator);
    equal(requestCalled, false);
    equal(logoutCalled, false);
    $('#persona_login').click();
    equal(requestCalled, true, 'login request called correctly');
    equal(logoutCalled, false);
    $('#logout').click();
    return equal(logoutCalled, true, 'logout callback called correctly');
  });

  setInputSgf = function(sgf) {
    return $('input#data').val(sgf);
  };

  module("common game page functions", {
    setup: function() {
      setInputSgf('');
      return tesuji_charm.game_common.initialize();
    }
  });

  test("initialize creates board from SGF data", function(assert) {
    setInputSgf('(;SZ[3];B[ca];W[bc])');
    tesuji_charm.game_common.initialize();
    assert.equal($('.goban').length, 1, "exactly one goban element exists");
    assert.ok(isPointEmpty($pointAt(0, 0)), "(0,0) empty");
    assert.ok(isPointBlack($pointAt(2, 0)), "(2,0) black");
    assert.ok(isPointWhite($pointAt(1, 2)), "(1,2) white");
    assert.ok($('.row-2.col-2').length === 1, "board is at least 3x3");
    return assert.ok($('.row-3.col-3').length === 0, "board is smaller than 4x4");
  });

  test("setup stones in SGF (tags AB & AW)", function(assert) {
    var expected;
    setInputSgf('(;SZ[3];AB[ba][ab][bc]AW[bb])');
    tesuji_charm.game_common.initialize();
    expected = [['empty', 'black', 'empty'], ['black', 'white', 'empty'], ['empty', 'black', 'empty']];
    return assert.deepEqual(tesuji_charm.game_common.readBoardState(), expected);
  });

  test("helper function readBoardState", function(assert) {
    var expected;
    setInputSgf('(;SZ[3];B[ca];W[bc])');
    tesuji_charm.game_common.initialize();
    expected = [['empty', 'empty', 'black'], ['empty', 'empty', 'empty'], ['empty', 'white', 'empty']];
    return assert.deepEqual(tesuji_charm.game_common.readBoardState(), expected);
  });

  module('Basic game page', {
    setup: function() {
      setInputSgf('(;SZ[3])');
      $('input#response').val('');
      return tesuji_charm.game_basic.initialize();
    }
  });

  test('clicking multiple points moves black stone', function() {
    var $point1, $point2;
    $point1 = $pointAt(0, 0);
    $point2 = $pointAt(1, 2);
    ok(isPointEmpty($point1), 'first point is initially empty');
    $point1.click();
    notOk(isPointEmpty($point1), 'after click, no longer empty');
    ok(isPointBlack($point1), 'after click, is black stone');
    $point2.click();
    ok(isPointEmpty($point1), 'after second click, first clicked point clear');
    return ok(isPointBlack($point2), 'after second click, second clicked point black');
  });

  test("white stones play correctly", function() {
    var $point;
    setInputSgf('(;SZ[3];B[aa])');
    tesuji_charm.game_basic.initialize();
    $point = $pointAt(1, 1);
    $point.click();
    return ok(isPointWhite($point), 'second player should be White');
  });

  test("next player correctly determined with info node", function() {
    var $point;
    setInputSgf('(;SZ[3])');
    tesuji_charm.game_basic.initialize();
    $point = $pointAt(1, 1);
    $point.click();
    return ok(isPointBlack($point), 'first player should be Black despite SGF info node');
  });

  test('clicking multiple points updates hidden form', function() {
    var $point1, $point2, $response;
    setInputSgf('(;)');
    tesuji_charm.game_basic.initialize();
    $point1 = $pointAt(0, 0);
    $point2 = $pointAt(1, 2);
    $response = $('input#response');
    $point1.click();
    equal($response.val(), '(;B[aa])', "first stone sets correct SGF");
    $point2.click();
    return equal($response.val(), '(;B[bc])', "second stone sets correct SGF");
  });

  test('Confirm button disabled until stone placed', function() {
    var $button;
    $button = $('button.confirm_button');
    equal($button.prop('disabled'), true, 'starts out disabled');
    $('table.goban td').first().click();
    return equal($button.prop('disabled'), false, 'enabled after stone placed');
  });

  test("clicking a pre-existing stone does nothing", function(assert) {
    var $point;
    setInputSgf('(;SZ[3];AW[bb])');
    tesuji_charm.game_basic.initialize();
    $point = $pointAt(1, 1);
    $point.click();
    assert.notOk(isPointBlack($point), "point has not become black");
    return assert.notOk($('input#response').val().match(/B\[bb]/), "SGF response does not contain black stone");
  });

  test("captured stones are removed from the board", function(assert) {
    setInputSgf('(;SZ[3];B[ba];W[aa])');
    tesuji_charm.game_basic.initialize();
    $pointAt(0, 1).click();
    return assert.ok(isPointEmpty($pointAt(0, 0)), "corner point is now empty");
  });

  module('Game page with marking interface', {
    beforeEach: function() {
      $("#qunit-fixture").append($("<div/>", {
        id: 'with_scoring',
        "class": 'with_scoring'
      }));
      return setInputSgf('(;SZ[3])');
    }
  });

  test("clicking empty points in marking mode does nothing", function(assert) {
    var $point;
    tesuji_charm.game_marking.initialize();
    $point = $pointAt(1, 1);
    assert.ok(isPointEmpty($point), "centre point starts empty");
    $point.click();
    return assert.ok(isPointEmpty($point), "still empty after click");
  });

  test("mixed scoring board", function(assert) {
    var x, y, _i, _len, _ref, _ref1;
    setInputSgf('(;SZ[3];B[ba];W[bb];B[ab];W[cb];B[cc];W[bc])');
    tesuji_charm.game_marking.initialize();
    assert.ok(isPointBlackScore($pointAt(0, 0)), "(0,0) black");
    assert.notOk(isPointWhiteScore($pointAt(0, 0)), "(0,0) white");
    _ref = [[0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1]];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], x = _ref1[0], y = _ref1[1];
      assert.notOk(isPointBlackScore($pointAt(x, y)), "(" + x + "," + y + ") black");
      assert.notOk(isPointWhiteScore($pointAt(x, y)), "(" + x + "," + y + ") white");
    }
    assert.notOk(isPointBlackScore($pointAt(2, 2)), "(2,2) black");
    return assert.ok(isPointWhiteScore($pointAt(2, 2)), "(2,2) white");
  });

  test("clicking live stones makes them dead, " + "clicking again brings them back", function(assert) {
    setInputSgf('(;SZ[3];B[aa];W[ab];B[bb];W[ca];B[bc];W[cc];B[ac])');
    tesuji_charm.game_marking.initialize();
    $pointAt(1, 1).click();
    assert.ok(isPointBlackDead($pointAt(1, 1)), "clicked stone (1, 1) is marked dead");
    assert.ok(isPointWhiteScore($pointAt(1, 1)), "dead black stone (1, 1) has white score class");
    assert.ok(isPointBlackDead($pointAt(0, 0)), "other black stone (0, 0) in the region is also dead");
    assert.ok(isPointWhiteScore($pointAt(0, 1)), "(0, 1) becomes white score with black stones dead");
    assert.ok(isPointWhiteScore($pointAt(2, 1)), "(2, 1) becomes white score with black stones dead");
    $pointAt(1, 1).click();
    assert.ok(isPointBlack($pointAt(1, 1)), "clicked stone (1, 1) is live again");
    assert.notOk(isPointWhiteScore($pointAt(1, 1)), "revived stone (1, 1) no longer counts as white score");
    assert.ok(isPointBlack($pointAt(0, 0)), "other dead stone (0, 0) is live again");
    assert.ok(isPointBlackScore($pointAt(0, 1)), "(0, 1) counts for black again with black stones restored");
    return assert.notOk(isPointWhiteScore($pointAt(2, 1)), "(2, 1) is neutral again with black stones restored");
  });

  test("killing stones revives neighbouring enemy groups " + "automatically", function(assert) {
    setInputSgf('(;SZ[3];AB[aa][ca][bb][ac][bc]AW[cc])');
    tesuji_charm.game_marking.initialize();
    $pointAt(1, 1).click();
    $pointAt(2, 2).click();
    assert.notOk(isPointBlackDead($pointAt(1, 1)), "first clicked stone (1, 1) is no longer dead");
    return assert.notOk(isPointBlackDead($pointAt(0, 0)), "neighboring black group (0, 0) is no longer dead");
  });

  test("initialization sets initial dead stones from SGF", function(assert) {
    setInputSgf('(;SZ[3];B[aa];W[ab];B[bb];W[ca];B[bc];W[cc];B[ac] ;W[];B[];TW[aa][ba][bb][bc][ac][bc])');
    tesuji_charm.game_marking.initialize();
    assert.ok(isPointBlackDead($pointAt(0, 0)), "(0, 0) is dead");
    assert.ok(isPointBlackDead($pointAt(1, 1)), "(1, 1) is dead");
    assert.ok(isPointWhiteScore($pointAt(0, 1)), "(0, 1) scores for White");
    return assert.ok(isPointWhiteScore($pointAt(1, 1)), "(1, 1) scores for White");
  });

  test("Form is updated with current dead stones", function(assert) {
    var actual, expected;
    setInputSgf('(;SZ[3];AB[aa][ac][bb][ac][bc]AW[cc])');
    tesuji_charm.game_marking.initialize();
    $pointAt(1, 1).click();
    expected = /AB(\[\w\w]){5}.*TW(\[\w\w]){8}/;
    actual = $('input#response').val();
    assert.ok(actual.match(expected), "correct number of TW coords");
    $pointAt(2, 2).click();
    expected = /TB[\]\[\w]*\[cc]/;
    actual = $('input#response').val();
    return assert.ok(actual.match(expected), "dead white stone found as black territory");
  });

  module('Go rules');

  go_rules = tesuji_charm.go_rules;

  QUnit.assert.legal = function(color, x, y, state, message) {
    go_rules.getNewState(color, x, y, state);
    return this.push(true, true, true, message != null ? message : "move is legal");
  };

  QUnit.assert.illegal = function(color, x, y, state, message) {
    var error;
    try {
      go_rules.getNewState(color, x, y, state);
    } catch (_error) {
      error = _error;
      if (error.message === 'illegal move') {
        this.push(true, false, false, message != null ? message : "move is illegal");
        return;
      }
    }
    return this.push(false, true, false, message != null ? message : "move is illegal");
  };

  test("playing on an existing stone is illegal", function(assert) {
    var board;
    board = [['empty', 'black'], ['empty', 'empty']];
    assert.legal('white', 0, 1, board);
    return assert.illegal('white', 1, 0, board);
  });

  test("playing a stone with no liberties is illegal", function(assert) {
    var board;
    board = [['empty', 'black'], ['black', 'empty']];
    assert.illegal('white', 0, 0, board, "white stone surrounded by black");
    board = [['empty', 'black'], ['black', 'black']];
    return assert.illegal('black', 0, 0, board, "black stone filling the board with black");
  });

  test("a move that would have no liberties is legal if it captures", function(assert) {
    var board;
    board = [['empty', 'black'], ['black', 'black']];
    return assert.legal('white', 0, 0, board);
  });

  test("playing a move sets the point color", function(assert) {
    var board, plusBlack, plusWhite;
    board = [['empty', 'black'], ['empty', 'empty']];
    plusBlack = [['empty', 'black'], ['black', 'empty']];
    plusWhite = [['empty', 'black'], ['white', 'empty']];
    assert.deepEqual(go_rules.getNewState('black', 0, 1, board), plusBlack);
    return assert.deepEqual(go_rules.getNewState('white', 0, 1, board), plusWhite);
  });

  test("removing a single stone's last liberty removes it", function(assert) {
    var afterCapture, board;
    board = [['white', 'black'], ['empty', 'empty']];
    afterCapture = [['empty', 'black'], ['black', 'empty']];
    return assert.deepEqual(go_rules.getNewState('black', 0, 1, board), afterCapture);
  });

  test("removing a group's last liberty removes the group", function(assert) {
    var b1, b2, board, expected;
    board = [['empty', 'empty', 'black', 'empty'], ['black', 'white', 'white', 'empty'], ['empty', 'black', 'black', 'empty']];
    b1 = go_rules.getNewState('black', 3, 1, board);
    assert.equal(b1[1][2], 'white', "white stones still around with one liberty remaining");
    b2 = go_rules.getNewState('black', 1, 0, b1);
    expected = [['empty', 'black', 'black', 'empty'], ['black', 'empty', 'empty', 'black'], ['empty', 'black', 'black', 'empty']];
    return assert.deepEqual(b2, expected, "group capture succeeded");
  });

  test("capturing with own last liberty does not remove own stones", function(assert) {
    var b1, board, expected;
    board = [['empty', 'black', 'black', 'empty'], ['black', 'white', 'white', 'black'], ['black', 'empty', 'white', 'black'], ['white', 'black', 'black', 'white'], ['empty', 'white', 'white', 'empty']];
    expected = [['empty', 'black', 'black', 'empty'], ['black', 'white', 'white', 'black'], ['black', 'white', 'white', 'black'], ['white', 'empty', 'empty', 'white'], ['empty', 'white', 'white', 'empty']];
    b1 = go_rules.getNewState('white', 1, 2, board);
    return assert.deepEqual(b1, expected, "group capture succeeded");
  });

  test("helper function neighboringPoints", function(assert) {
    var board;
    board = [['empty', 'empty', 'empty'], ['empty', 'empty', 'empty'], ['empty', 'empty', 'empty']];
    assert.equal(go_rules.neighboringPoints(0, 0, board).length, 2);
    assert.equal(go_rules.neighboringPoints(1, 0, board).length, 3);
    return assert.equal(go_rules.neighboringPoints(1, 1, board).length, 4);
  });

  test("_countLiberties: single stones", function(assert) {
    var board;
    board = [['black', 'empty', 'black'], ['empty', 'black', 'white'], ['empty', 'empty', 'empty']];
    assert.equal(go_rules._countLiberties(0, 0, board), 2);
    assert.equal(go_rules._countLiberties(1, 1, board), 3);
    return assert.equal(go_rules._countLiberties(2, 1, board), 1);
  });

  test("_countLiberties: groups share liberties", function(assert) {
    var board;
    board = [['black', 'black', 'empty'], ['black', 'white', 'white'], ['empty', 'black', 'empty']];
    assert.equal(go_rules._countLiberties(1, 0, board), 2);
    return assert.equal(go_rules._countLiberties(1, 1, board), 2);
  });

  test("_countLiberties: regression test: shared liberties not double counted", function(assert) {
    var board;
    board = [['black', 'black', 'empty'], ['black', 'empty', 'white'], ['empty', 'black', 'empty']];
    return assert.equal(go_rules._countLiberties(1, 0, board), 3, "centre liberty counts only once, for total of 3");
  });

  test("groupPoints: identifies groups correctly", function(assert) {
    var blackGroup, board, whiteGroup;
    board = [['black', 'black', 'empty'], ['black', 'white', 'white'], ['empty', 'black', 'empty']];
    blackGroup = [[1, 0], [0, 0], [0, 1]];
    whiteGroup = [[1, 1], [2, 1]];
    assert.deepEqual(go_rules.groupPoints(1, 0, board), blackGroup, "black group");
    return assert.deepEqual(go_rules.groupPoints(1, 1, board), whiteGroup, "white group");
  });

  test("groupPoints: optional argument 'colors' works", function(assert) {
    var actual, board, expected;
    board = [['blackdead', 'blackdead', 'empty'], ['black', 'empty', 'white'], ['empty', 'black', 'white']];
    expected = [[0, 0], [1, 0], [1, 1], [2, 0]];
    actual = go_rules.groupPoints(0, 0, board, ['empty', 'blackdead']);
    return assert.deepEqual(actual, expected);
  });

}).call(this);
