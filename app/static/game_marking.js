// Generated by CoffeeScript 1.9.1
(function() {
  var $pointAt, game_common, game_marking, getEmptyRegions, go_rules, setRegionScores, setupScoring, tesuji_charm,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (window.tesuji_charm == null) {
    window.tesuji_charm = {};
  }

  tesuji_charm = window.tesuji_charm;

  if (tesuji_charm.game_marking == null) {
    tesuji_charm.game_marking = {};
  }

  game_marking = tesuji_charm.game_marking;

  game_common = tesuji_charm.game_common;

  $pointAt = game_common.$pointAt;

  go_rules = tesuji_charm.go_rules;

  game_marking.initialize = function() {
    setupScoring();
    return $('table.goban td').click(function() {
      var $point, col, k, len, newColor, ref, ref1, ref2, row, x, y;
      if (!game_common.hasCoordClass($(this))) {
        return;
      }
      ref = game_common.parseCoordClass($(this)), row = ref[0], col = ref[1];
      $point = $pointAt(col, row);
      if ($point.hasClass('blackstone')) {
        newColor = 'blackdead';
      } else if ($point.hasClass('blackdead')) {
        newColor = 'black';
      } else if ($point.hasClass('whitestone')) {
        newColor = 'whitedead';
      } else if ($point.hasClass('whitedead')) {
        newColor = 'white';
      } else {
        return;
      }
      ref1 = go_rules.groupPoints(col, row, game_common.readBoardState());
      for (k = 0, len = ref1.length; k < len; k++) {
        ref2 = ref1[k], x = ref2[0], y = ref2[1];
        game_common.setPointColor($pointAt(x, y), newColor);
      }
      return setupScoring();
    });
  };

  setupScoring = function() {
    var boundary, col, k, len, ref, ref1, region, row, state;
    state = game_common.readBoardState();
    ref = getEmptyRegions(state);
    for (k = 0, len = ref.length; k < len; k++) {
      region = ref[k];
      ref1 = region[0], col = ref1[0], row = ref1[1];
      boundary = go_rules.boundingColor(region, state);
      setRegionScores(region, (function() {
        switch (boundary) {
          case 'black':
            return 'blackscore';
          case 'white':
            return 'whitescore';
          case 'neither':
            return 'empty';
        }
      })());
    }
  };

  getEmptyRegions = function(state) {
    var col, color, done, emptyColors, height, i, j, k, l, len, len1, len2, m, ref, ref1, region, regions, row, rowArray, width, x, y;
    regions = [];
    emptyColors = ['empty', 'blackdead', 'whitedead'];
    height = state.length;
    width = state[0].length;
    done = (function() {
      var k, ref, results;
      results = [];
      for (j = k = 0, ref = height; 0 <= ref ? k <= ref : k >= ref; j = 0 <= ref ? ++k : --k) {
        results.push((function() {
          var l, ref1, results1;
          results1 = [];
          for (i = l = 0, ref1 = width; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
            results1.push(false);
          }
          return results1;
        })());
      }
      return results;
    })();
    for (row = k = 0, len = state.length; k < len; row = ++k) {
      rowArray = state[row];
      for (col = l = 0, len1 = rowArray.length; l < len1; col = ++l) {
        color = rowArray[col];
        if (done[row][col]) {
          continue;
        }
        if (ref = state[row][col], indexOf.call(emptyColors, ref) >= 0) {
          region = go_rules.groupPoints(col, row, state, emptyColors);
          for (m = 0, len2 = region.length; m < len2; m++) {
            ref1 = region[m], x = ref1[0], y = ref1[1];
            done[y][x] = true;
          }
          regions.push(region);
        }
      }
    }
    return regions;
  };

  setRegionScores = function(region, scoreColor) {
    var $point, k, len, ref, x, y;
    for (k = 0, len = region.length; k < len; k++) {
      ref = region[k], x = ref[0], y = ref[1];
      $point = $pointAt(x, y);
      if ($point.hasClass('nostone')) {
        game_common.setPointColor($point, scoreColor);
      }
    }
  };

}).call(this);
