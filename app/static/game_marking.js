// Generated by CoffeeScript 1.9.1
(function() {
  var $pointAt, game_common, game_marking, getEmptyRegions, go_rules, markStonesAround, setRegionScores, setupScoring, tesuji_charm, toggleRegion,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (window.tesuji_charm == null) {
    window.tesuji_charm = {};
  }

  tesuji_charm = window.tesuji_charm;

  if (tesuji_charm.game_marking == null) {
    tesuji_charm.game_marking = {};
  }

  game_marking = tesuji_charm.game_marking;

  game_common = tesuji_charm.game_common;

  $pointAt = game_common.$pointAt;

  go_rules = tesuji_charm.go_rules;

  game_marking.initialize = function() {
    setupScoring();
    return $('table.goban td').click(function() {
      var col, ref, row;
      if (!game_common.hasCoordClass($(this))) {
        return;
      }
      ref = game_common.parseCoordClass($(this)), row = ref[0], col = ref[1];
      markStonesAround(col, row);
      return setupScoring();
    });
  };

  setupScoring = function() {
    var boundary, col, k, len, ref, ref1, region, row, state;
    state = game_common.readBoardState();
    ref = getEmptyRegions(state);
    for (k = 0, len = ref.length; k < len; k++) {
      region = ref[k];
      ref1 = region[0], col = ref1[0], row = ref1[1];
      boundary = go_rules.boundingColor(region, state);
      setRegionScores(region, (function() {
        switch (boundary) {
          case 'black':
            return 'blackscore';
          case 'white':
            return 'whitescore';
          case 'neither':
            return 'empty';
          default:
            throw new Error("invalid boundary color: '" + boundary + "'");
        }
      })());
    }
  };

  getEmptyRegions = function(state) {
    var col, color, done, emptyColors, height, i, j, k, l, len, len1, len2, m, ref, ref1, region, regions, row, rowArray, width, x, y;
    regions = [];
    emptyColors = ['empty', 'blackdead', 'whitedead'];
    height = state.length;
    width = state[0].length;
    done = (function() {
      var k, ref, results;
      results = [];
      for (j = k = 0, ref = height; 0 <= ref ? k <= ref : k >= ref; j = 0 <= ref ? ++k : --k) {
        results.push((function() {
          var l, ref1, results1;
          results1 = [];
          for (i = l = 0, ref1 = width; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
            results1.push(false);
          }
          return results1;
        })());
      }
      return results;
    })();
    for (row = k = 0, len = state.length; k < len; row = ++k) {
      rowArray = state[row];
      for (col = l = 0, len1 = rowArray.length; l < len1; col = ++l) {
        color = rowArray[col];
        if (done[row][col]) {
          continue;
        }
        if (ref = state[row][col], indexOf.call(emptyColors, ref) >= 0) {
          region = go_rules.groupPoints(col, row, state, emptyColors);
          for (m = 0, len2 = region.length; m < len2; m++) {
            ref1 = region[m], x = ref1[0], y = ref1[1];
            done[y][x] = true;
          }
          regions.push(region);
        }
      }
    }
    return regions;
  };

  setRegionScores = function(region, scoreColor) {
    var $point, k, len, ref, x, y;
    for (k = 0, len = region.length; k < len; k++) {
      ref = region[k], x = ref[0], y = ref[1];
      $point = $pointAt(x, y);
      if ($point.hasClass('nostone')) {
        game_common.setPointColor($point, scoreColor);
      }
    }
  };

  markStonesAround = function(x, y) {
    "Toggle the life/death status of the given point and all friendly stones in the region (ie. the area bounded by unfriendly stones). We don't trigger scoring recalculation here, that's for the caller to do.";
    var color, region, state;
    color = game_common.colorFromDom($pointAt(x, y));
    if (color === 'empty') {
      return;
    }
    state = game_common.readBoardState();
    region = go_rules.groupPoints(x, y, state, ['empty', color]);
    toggleRegion(region);
  };

  toggleRegion = function(region) {
    "In the given region, mark live stones as dead and dead stones as alive.";
    var $point, color, k, len, newColor, ref, x, y;
    for (k = 0, len = region.length; k < len; k++) {
      ref = region[k], x = ref[0], y = ref[1];
      $point = $pointAt(x, y);
      color = game_common.colorFromDom($point);
      if (color === 'empty') {
        continue;
      }
      newColor = (function() {
        switch (color) {
          case 'black':
            return 'blackdead';
          case 'white':
            return 'whitedead';
          case 'blackdead':
            return 'black';
          case 'whitedead':
            return 'white';
          default:
            return null;
        }
      })();
      if (newColor) {
        game_common.setPointColor($point, newColor);
      }
    }
  };

}).call(this);
