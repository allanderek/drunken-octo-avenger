// Generated by CoffeeScript 1.9.1
(function() {
  var $pointAt, clearScores, game_common, game_marking, go_rules, setupScoring, tesuji_charm;

  if (window.tesuji_charm == null) {
    window.tesuji_charm = {};
  }

  tesuji_charm = window.tesuji_charm;

  if (tesuji_charm.game_marking == null) {
    tesuji_charm.game_marking = {};
  }

  game_marking = tesuji_charm.game_marking;

  game_common = tesuji_charm.game_common;

  $pointAt = game_common.$pointAt;

  go_rules = tesuji_charm.go_rules;

  setupScoring = function() {
    var $td, $td0, boundary, col, color, i, len, ref, ref1, row, rowArray, scoreColor, state, x, y;
    state = game_common.readBoardState();
    clearScores(state);
    for (row in state) {
      rowArray = state[row];
      row = parseInt(row, 10);
      for (col in rowArray) {
        color = rowArray[col];
        col = parseInt(col, 10);
        $td = $pointAt(col, row);
        if ($td.hasClass('blackscore')) {
          continue;
        }
        if ($td.hasClass('whitescore')) {
          continue;
        }
        if (($td.hasClass('blackstone')) || ($td.hasClass('whitestone'))) {
          continue;
        }
        boundary = go_rules.boundingColor(col, row, state);
        if (boundary === 'neither') {
          continue;
        }
        scoreColor = (function() {
          switch (boundary) {
            case 'black':
              return 'blackscore';
            case 'white':
              return 'whitescore';
          }
        })();
        ref = go_rules._groupPoints(col, row, state);
        for (i = 0, len = ref.length; i < len; i++) {
          ref1 = ref[i], x = ref1[0], y = ref1[1];
          $td0 = $pointAt(x, y);
          if ($td0.hasClass('blackdead')) {
            game_common.setPointColor($td0, 'blackdead');
          } else if ($td0.hasClass('whitedead')) {
            game_common.setPointColor($td0, 'whitedead');
          } else {
            game_common.setPointColor($td0, scoreColor);
          }
        }
      }
    }
  };

  clearScores = function(state) {
    "remove score classes from board with dimensions taken from `state`";
    var $td, _, col, results, row, rowArray;
    results = [];
    for (row in state) {
      rowArray = state[row];
      results.push((function() {
        var results1;
        results1 = [];
        for (col in rowArray) {
          _ = rowArray[col];
          $td = $pointAt(col, row);
          $td.removeClass('blackscore');
          results1.push($td.removeClass('whitescore'));
        }
        return results1;
      })());
    }
    return results;
  };

  game_marking.initialize = function() {
    setupScoring();
    return $('table.goban td').click(function() {
      var $point, col, i, len, newColor, ref, ref1, ref2, row, x, y;
      if (!game_common.hasCoordClass($(this))) {
        return;
      }
      ref = game_common.parseCoordClass($(this)), row = ref[0], col = ref[1];
      $point = $pointAt(col, row);
      if ($point.hasClass('blackstone')) {
        newColor = 'blackdead';
      } else if ($point.hasClass('whitestone')) {
        newColor = 'whitedead';
      } else {
        return;
      }
      ref1 = go_rules._groupPoints(col, row, game_common.readBoardState());
      for (i = 0, len = ref1.length; i < len; i++) {
        ref2 = ref1[i], x = ref2[0], y = ref2[1];
        game_common.setPointColor($pointAt(x, y), newColor);
      }
      return setupScoring();
    });
  };

}).call(this);
