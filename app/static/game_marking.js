// Generated by CoffeeScript 1.9.1
(function() {
  var $pointAt, game_common, game_marking, getEmptyRegions, go_rules, markStonesAround, reviveAroundRegion, setRegionScores, setupScoring, tesuji_charm, togglePoints,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (window.tesuji_charm == null) {
    window.tesuji_charm = {};
  }

  tesuji_charm = window.tesuji_charm;

  if (tesuji_charm.game_marking == null) {
    tesuji_charm.game_marking = {};
  }

  game_marking = tesuji_charm.game_marking;

  game_common = tesuji_charm.game_common;

  $pointAt = game_common.$pointAt;

  go_rules = tesuji_charm.go_rules;

  game_marking.initialize = function() {
    setupScoring();
    return $('table.goban td').click(function() {
      var col, ref, row;
      if (!game_common.hasCoordClass($(this))) {
        return;
      }
      ref = game_common.parseCoordClass($(this)), row = ref[0], col = ref[1];
      markStonesAround(col, row);
      return setupScoring();
    });
  };

  setupScoring = function() {
    "set/remove scoring classes on the DOM based on current live/dead state of all stones";
    var boundary, col, k, len, ref, ref1, region, row, state;
    state = game_common.readBoardState();
    ref = getEmptyRegions(state);
    for (k = 0, len = ref.length; k < len; k++) {
      region = ref[k];
      ref1 = region[0], col = ref1[0], row = ref1[1];
      boundary = go_rules.boundingColor(region, state);
      setRegionScores(region, (function() {
        switch (boundary) {
          case 'black':
            return 'blackscore';
          case 'white':
            return 'whitescore';
          case 'neither':
            return 'empty';
          default:
            throw new Error("invalid boundary color: '" + boundary + "'");
        }
      })());
    }
  };

  getEmptyRegions = function(state) {
    var col, color, done, emptyColors, height, i, j, k, l, len, len1, len2, m, ref, ref1, region, regions, row, rowArray, width, x, y;
    regions = [];
    emptyColors = ['empty', 'blackdead', 'whitedead'];
    height = state.length;
    width = state[0].length;
    done = (function() {
      var k, ref, results;
      results = [];
      for (j = k = 0, ref = height; 0 <= ref ? k <= ref : k >= ref; j = 0 <= ref ? ++k : --k) {
        results.push((function() {
          var l, ref1, results1;
          results1 = [];
          for (i = l = 0, ref1 = width; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
            results1.push(false);
          }
          return results1;
        })());
      }
      return results;
    })();
    for (row = k = 0, len = state.length; k < len; row = ++k) {
      rowArray = state[row];
      for (col = l = 0, len1 = rowArray.length; l < len1; col = ++l) {
        color = rowArray[col];
        if (done[row][col]) {
          continue;
        }
        if (ref = state[row][col], indexOf.call(emptyColors, ref) >= 0) {
          region = go_rules.groupPoints(col, row, state, emptyColors);
          for (m = 0, len2 = region.length; m < len2; m++) {
            ref1 = region[m], x = ref1[0], y = ref1[1];
            done[y][x] = true;
          }
          regions.push(region);
        }
      }
    }
    return regions;
  };

  setRegionScores = function(region, scoreColor) {
    var $point, k, len, ref, x, y;
    for (k = 0, len = region.length; k < len; k++) {
      ref = region[k], x = ref[0], y = ref[1];
      $point = $pointAt(x, y);
      if (game_common.colorFromDom($point) === 'empty') {
        game_common.setPointColor($point, scoreColor);
      }
    }
  };

  markStonesAround = function(x, y) {
    "Toggle the life/death status of the given point and all friendly stones in the region (ie. the area bounded by unfriendly stones).  If killing stones, also revive surrounding enemy stones. We don't trigger scoring recalculation here, that's for the caller to do.";
    var color, isKilling, region, state;
    color = game_common.colorFromDom($pointAt(x, y));
    if (color === 'empty') {
      return;
    }
    isKilling = color === 'black' || color === 'white';
    state = game_common.readBoardState();
    region = go_rules.groupPoints(x, y, state, ['empty', color]);
    togglePoints(region);
    if (isKilling) {
      reviveAroundRegion(region, state);
    }
  };

  reviveAroundRegion = function(region, state) {
    "Revive all dead groups touching, but not in, the given region; together with friendly stones in their own regions.";
    var height, i, ignore, j, k, l, len, len1, len2, len3, m, n, neighborColor, neighborRegion, ref, ref1, ref2, ref3, ref4, width, x, xg, xn, y, yg, yn;
    height = state.length;
    width = state[0].length;
    ignore = (function() {
      var k, ref, results;
      results = [];
      for (j = k = 0, ref = height; 0 <= ref ? k <= ref : k >= ref; j = 0 <= ref ? ++k : --k) {
        results.push((function() {
          var l, ref1, results1;
          results1 = [];
          for (i = l = 0, ref1 = width; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
            results1.push(false);
          }
          return results1;
        })());
      }
      return results;
    })();
    for (k = 0, len = region.length; k < len; k++) {
      ref = region[k], x = ref[0], y = ref[1];
      ignore[y][x] = true;
    }
    for (l = 0, len1 = region.length; l < len1; l++) {
      ref1 = region[l], x = ref1[0], y = ref1[1];
      ref2 = go_rules.neighboringPoints(x, y, state);
      for (m = 0, len2 = ref2.length; m < len2; m++) {
        ref3 = ref2[m], xn = ref3[0], yn = ref3[1];
        if (ignore[yn][xn]) {
          continue;
        }
        ignore[yn][xn] = true;
        neighborColor = state[yn][xn];
        if (neighborColor === 'blackdead' || neighborColor === 'whitedead') {
          neighborRegion = go_rules.groupPoints(xn, yn, state, ['empty', neighborColor]);
          togglePoints(neighborRegion);
          for (n = 0, len3 = neighborRegion.length; n < len3; n++) {
            ref4 = neighborRegion[n], xg = ref4[0], yg = ref4[1];
            ignore[yg][xg] = true;
          }
        }
      }
    }
  };

  togglePoints = function(points) {
    "Among the given points, mark live stones as dead and dead stones as alive.";
    var $point, color, k, len, newColor, ref, x, y;
    for (k = 0, len = points.length; k < len; k++) {
      ref = points[k], x = ref[0], y = ref[1];
      $point = $pointAt(x, y);
      color = game_common.colorFromDom($point);
      if (color === 'empty') {
        continue;
      }
      newColor = (function() {
        switch (color) {
          case 'black':
            return 'blackdead';
          case 'white':
            return 'whitedead';
          case 'blackdead':
            return 'black';
          case 'whitedead':
            return 'white';
          default:
            return null;
        }
      })();
      if (newColor) {
        game_common.setPointColor($point, newColor);
      }
    }
  };

}).call(this);
