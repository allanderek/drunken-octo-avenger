// Generated by CoffeeScript 1.9.1
(function() {
  var $newStone, $pointAt, clearScores, colRe, game_basic, getStoneClass, go_rules, hasCoordClass, initialBoardState, markingClickFunc, newStoneColor, normalClickFunc, parseCoordClass, readBoardState, rowRe, setImage, setPointColor, setStoneClass, setupScoring, tesuji_charm, updateBoard, updateBoardChars;

  if (window.tesuji_charm == null) {
    window.tesuji_charm = {};
  }

  tesuji_charm = window.tesuji_charm;

  if (tesuji_charm.game_basic == null) {
    tesuji_charm.game_basic = {};
  }

  game_basic = tesuji_charm.game_basic;

  go_rules = tesuji_charm.go_rules;

  initialBoardState = null;

  $newStone = null;

  newStoneColor = null;

  setImage = function($td, filename) {
    return $td.find('img').attr('src', "/static/images/goban/" + filename);
  };

  setStoneClass = function($td, stoneclass) {
    return $td.removeClass('blackstone whitestone nostone').addClass(stoneclass);
  };

  setPointColor = function($td, color) {
    var filename, ref, stoneclass;
    ref = (function() {
      switch (color) {
        case 'empty':
          return ['e.gif', 'nostone'];
        case 'black':
          return ['b.gif', 'blackstone'];
        case 'white':
          return ['w.gif', 'whitestone'];
      }
    })(), filename = ref[0], stoneclass = ref[1];
    setImage($td, filename);
    return setStoneClass($td, stoneclass);
  };

  $pointAt = function(x, y) {
    return $(".row-" + y + ".col-" + x);
  };

  rowRe = /row-(\d+)/;

  colRe = /col-(\d+)/;

  hasCoordClass = function($obj) {
    var classStr;
    classStr = $obj.attr("class");
    return rowRe.test(classStr) && colRe.test(classStr);
  };

  parseCoordClass = function($obj) {
    var _, classStr, colStr, ref, ref1, rowStr;
    classStr = $obj.attr("class");
    ref = rowRe.exec($obj.attr("class")), _ = ref[0], rowStr = ref[1];
    ref1 = colRe.exec($obj.attr("class")), _ = ref1[0], colStr = ref1[1];
    return [parseInt(rowStr, 10), parseInt(colStr, 10)];
  };

  getStoneClass = function($obj) {
    var classStr;
    classStr = $obj.attr("class");
    if (classStr.indexOf('blackstone') > -1) {
      return 'blackstone';
    }
    if (classStr.indexOf('whitestone') > -1) {
      return 'whitestone';
    }
    return '';
  };

  readBoardState = function() {
    var result;
    result = [];
    $('.goban td').each(function(index) {
      var col, ref, row;
      ref = parseCoordClass($(this)), row = ref[0], col = ref[1];
      if (result[row] == null) {
        result[row] = [];
      }
      return result[row][col] = (function() {
        switch (getStoneClass($(this))) {
          case 'blackstone':
            return 'black';
          case 'whitestone':
            return 'white';
          default:
            return 'empty';
        }
      }).call(this);
    });
    return result;
  };

  game_basic._readBoardState = readBoardState;

  updateBoard = function(state) {
    var $td, col, data, results, row, rowArray;
    results = [];
    for (row in state) {
      rowArray = state[row];
      results.push((function() {
        var results1;
        results1 = [];
        for (col in rowArray) {
          data = rowArray[col];
          $td = $pointAt(col, row);
          results1.push(setPointColor($td, data));
        }
        return results1;
      })());
    }
    return results;
  };

  game_basic._updateBoard = updateBoard;

  updateBoardChars = function(charArray) {
    var $td, char, col, color, results, row, rowString;
    results = [];
    for (row in charArray) {
      rowString = charArray[row];
      results.push((function() {
        var results1;
        results1 = [];
        for (col in rowString) {
          char = rowString[col];
          color = (function() {
            switch (char) {
              case "b":
                return "black";
              case "w":
                return "white";
              case ".":
                return "empty";
            }
          })();
          $td = $pointAt(col, row);
          results1.push(setPointColor($td, color));
        }
        return results1;
      })());
    }
    return results;
  };

  game_basic._updateBoardChars = updateBoardChars;

  game_basic._reloadBoard = function() {
    return initialBoardState = readBoardState();
  };

  setupScoring = function() {
    var $td, boundary, class_, col, color, i, len, ref, ref1, row, rowArray, state, x, y;
    state = readBoardState();
    clearScores(state);
    for (row in state) {
      rowArray = state[row];
      row = parseInt(row, 10);
      for (col in rowArray) {
        color = rowArray[col];
        col = parseInt(col, 10);
        $td = $pointAt(col, row);
        if ($td.hasClass('blackscore')) {
          continue;
        }
        if ($td.hasClass('whitescore')) {
          continue;
        }
        if (($td.hasClass('blackstone')) || ($td.hasClass('whitestone'))) {
          continue;
        }
        boundary = go_rules.boundingColor(col, row, state);
        if (boundary === 'neither') {
          continue;
        }
        class_ = (function() {
          switch (boundary) {
            case 'black':
              return 'blackscore';
            case 'white':
              return 'whitescore';
          }
        })();
        ref = go_rules._groupPoints(col, row, state);
        for (i = 0, len = ref.length; i < len; i++) {
          ref1 = ref[i], x = ref1[0], y = ref1[1];
          $td.addClass(class_);
        }
      }
    }
  };

  clearScores = function(state) {
    "remove score classes from board with dimensions taken from `state`";
    var $td, _, col, results, row, rowArray;
    results = [];
    for (row in state) {
      rowArray = state[row];
      results.push((function() {
        var results1;
        results1 = [];
        for (col in rowArray) {
          _ = rowArray[col];
          $td = $pointAt(col, row);
          $td.removeClass('blackscore');
          results1.push($td.removeClass('whitescore'));
        }
        return results1;
      })());
    }
    return results;
  };

  normalClickFunc = function() {
    var col, error, newBoardState, ref, row;
    if (!hasCoordClass($(this))) {
      return;
    }
    ref = parseCoordClass($(this)), row = ref[0], col = ref[1];
    try {
      newBoardState = go_rules.getNewState(newStoneColor, col, row, initialBoardState);
    } catch (_error) {
      error = _error;
      if (error.message === 'illegal move') {
        return;
      } else {
        throw error;
      }
    }
    updateBoard(newBoardState);
    $('input#row').val(row.toString());
    $('input#column').val(col.toString());
    return $('button.confirm_button').prop('disabled', false);
  };

  markingClickFunc = function() {
    var $point, col, i, len, newClass, oldClass, ref, ref1, ref2, row, x, y;
    if (!hasCoordClass($(this))) {
      return;
    }
    ref = parseCoordClass($(this)), row = ref[0], col = ref[1];
    $point = $pointAt(col, row);
    if ($point.hasClass('blackstone')) {
      oldClass = 'blackstone';
      newClass = 'blackdead';
    } else if ($point.hasClass('whitestone')) {
      oldClass = 'whitestone';
      newClass = 'whitedead';
    } else {
      return;
    }
    ref1 = go_rules._groupPoints(col, row, readBoardState());
    for (i = 0, len = ref1.length; i < len; i++) {
      ref2 = ref1[i], x = ref2[0], y = ref2[1];
      $pointAt(x, y).removeClass(oldClass);
      $pointAt(x, y).addClass(newClass);
    }
    return setupScoring();
  };

  game_basic.initialize = function() {
    initialBoardState = readBoardState();
    if (parseInt($('input#move_no').val()) % 2 === 0) {
      newStoneColor = 'black';
    } else {
      newStoneColor = 'white';
    }
    $('button.confirm_button').prop('disabled', true);
    if ($('.with_scoring').length) {
      setupScoring();
    }
    if (!$('.with_scoring').length) {
      return $('table.goban td').click(normalClickFunc);
    } else {
      return $('table.goban td').click(markingClickFunc);
    }
  };

}).call(this);
