window.tesuji_charm ?= {}
tesuji_charm = window.tesuji_charm

tesuji_charm.game ?= {}
exports = tesuji_charm.game


smartgame = tesuji_charm.smartgame
go_rules = tesuji_charm.go_rules


exports.$pointAt = $pointAt = (x, y) -> $(".row-#{y}.col-#{x}")
exports.getInputSgf = getInputSgf = -> $('input#data').val()
exports.setResponseSgf = setResponseSgf = (sgf) ->
  $('#response').val sgf

exports.getBlackPrisoners = -> parseInt($('.prisoners.black').text(), 10)
exports.getWhitePrisoners = -> parseInt($('.prisoners.white').text(), 10)

###
# setPointColor and helpers

exports.setPointColor = setPointColor = ($td, color) ->
  $('.stone', $td).remove()
  $('.territory', $td).remove()
  [stoneclass, territoryclass] = switch color
    when 'empty' then ['', '']
    when 'dame' then ['', 'territory neutral']
    when 'black' then ['stone black', '']
    when 'white' then ['stone white', '']
    when 'blackdead' then ['stone black dead', 'territory white']
    when 'whitedead' then ['stone white dead', 'territory black']
    when 'blackscore' then ['', 'territory black']
    when 'whitescore' then ['', 'territory white']
  if stoneclass
    stoneElement = document.createElement 'div'
    stoneElement.className = stoneclass
    $td.append stoneElement
  if territoryclass
    territoryElement = document.createElement 'div'
    territoryElement.className = territoryclass
    $td.append territoryElement

exports.setLastPlayed = setLastPlayed = ($point) ->
  $('.goban .last-played').remove()
  lastPlayedElement = document.createElement 'div'
  lastPlayedElement.className = 'last-played'
  $point.append lastPlayedElement

removeLastPlayed = ->
  $('.goban .last-played').remove()

# end of setPointColor helpers
###

exports.contains_selector = contains_selector = ($context, selector) ->
  "A helper function returns true if the given element/context contains an
   element that satisfies the selector."
  return ($context.find selector).length > 0

exports.colorFromDom = colorFromDom = ($point) ->
  "return the color of the given point based on the DOM status"
  # We do the dead ones first because a dead stone would still satisfy the
  # test for a white/black stone.
  if contains_selector $point, '.stone.black.dead' then return 'blackdead'
  if contains_selector $point, '.stone.white.dead' then return 'whitedead'
  if contains_selector $point, '.stone.black' then return 'black'
  if contains_selector $point, '.stone.white' then return 'white'
  if not (contains_selector $point, '.stone') then return 'empty'
  return null

exports.isBlackScore = ($point) ->
  return contains_selector $point, '.territory.black'

exports.isWhiteScore = ($point) ->
  return contains_selector $point, '.territory.white'

rowRe = /row-(\d+)/
colRe = /col-(\d+)/

exports.hasCoordClass = hasCoordClass = ($obj) ->
  classStr = $obj.attr "class"
  return rowRe.test(classStr) and colRe.test(classStr)

exports.parseCoordClass = parseCoordClass = ($obj) ->
  classStr = $obj.attr "class"
  [_, rowStr] = rowRe.exec classStr
  [_, colStr] = colRe.exec classStr
  return [parseInt(colStr, 10), parseInt(rowStr, 10)]

exports.readBoardState = readBoardState = ->
  "generate a board state object based on the loaded page contents"
  result = []
  $('.goban .gopoint').each ->
    $this = $(this)
    [col, row] = parseCoordClass $this
    result[row] ?= []
    result[row][col] = colorFromDom $this
  return result

isHandicapPoint = (size, row, column) ->
  switch size
    when 19 then row in [3,9,15] and column in [3,9,15]
    when 13 then (row in [3,9] and column in [3,9]) or row == column == 6
    when 9 then (row in [2,6] and column in [2,6]) or row == column == 4
    else false

exports.initialize = (sgfObject = null, newStoneColor = null) ->
  sgfObject or= smartgame.parse(getInputSgf() or '(;SZ[19])')
  size = parseInt(sgfObject.gameTrees[0].nodes[0].SZ, 10) or 19

  # can't put the response form under React control since it needs to be
  # generated by WTForms, server-side
  $('.confirm_button').prop('disabled', true)
  $('.pass_button').click ->
    newSgfObject = sgfObjectWithMoveAdded sgfObject
    newSgf = smartgame.generate newSgfObject
    setResponseSgf newSgf
    $('#main_form').get(0).submit()

  $('#board').empty()
  reactTop = React.render (React.createElement BoardAreaDom,
                                               initialSgf: getInputSgf()
                                               sgfObject: sgfObject),
                          $('#board')[0]
  return

BoardAreaDom = React.createClass
  getInitialState: ->
    deadStones: null
    proposedMove: null
    viewingMove: null

  onNavigate: (newViewingMove) ->
    # can't put the response form under React control since it needs to be
    # generated by WTForms, server-side
    $('.confirm_button').prop('disabled', true)
    setResponseSgf @props.initialSgf
    @setState
      deadStones: null
      proposedMove: null
      viewingMove: newViewingMove

  render: ->
    origSgfObject = @props.sgfObject
    if @state.proposedMove?
      sgfObject = sgfObjectWithMoveAdded(origSgfObject,
                                         @state.proposedMove.color,
                                         @state.proposedMove.x,
                                         @state.proposedMove.y)
    else
      sgfObject = origSgfObject

    moveToShow = if @state.viewingMove == null \
                 then null \
                 else if @state.proposedMove \
                      then @state.viewingMove + 1 \
                      else @state.viewingMove
    scoringMode = isPassedTwice sgfObject
    objState = stateFromSgfObject sgfObject,
                                  moves: moveToShow,
                                  scoring: scoringMode
                                  deadStones: @state.deadStones
    {boardState, lastPlayed, prisoners, scores} = objState
    size = parseInt(sgfObject.gameTrees[0].nodes[0].SZ, 10) or 19
    nextColor = null

    if scoringMode
      onBoardClick = (xy) =>
        newDead = getNewDeadForToggledPoint boardState, xy.x, xy.y
        @setState deadStones: newDead
    else if (tesuji_charm.onTurn and \
        (@state.viewingMove == null or \
         @state.viewingMove == moveCount(origSgfObject)))
      # ready to accept a normal (non-dead stone marking) move
      nextColor = nextPlayerInSgfObject origSgfObject
      onBoardClick = (xy) =>
        return if boardState[xy.y][xy.x] != 'empty'
        # can't put the response form under React control since it needs to be
        # generated by WTForms, server-side
        $('.confirm_button').prop('disabled', false)
        newSgfObject = sgfObjectWithMoveAdded origSgfObject,
                                              nextColor, xy.x, xy.y
        setResponseSgf smartgame.generate(newSgfObject)
        # back to React
        @setState proposedMove:
          color: nextColor
          x: xy.x
          y: xy.y
    else
      onBoardClick = ->

    {div} = React.DOM
    div {},
        [(React.createElement BoardDom,
                              boardState: boardState
                              hoverColor: nextColor
                              clickCallback: onBoardClick
                              lastPlayed: lastPlayed
                              size: size),
         (React.createElement NavigationDom,
                              changeCallback: @onNavigate,
                              sgfObject: origSgfObject,
                              viewingMove: @state.viewingMove),
         (React.createElement ScoreDom,
                              prisoners: prisoners
                              scores: scores)]

BoardDom = React.createClass
  render: ->
    # boardState is the complete state to show, with the newly proposed
    # stone included if there is one.  lastPlayed is only used to locate
    # the 'new stone' marker, the stone it refers to should already be in
    # the boardState.
    {boardState, lastPlayed, size} = @props

    {div} = React.DOM
    topVert = div {className: "board_line board_line_vertical"}
    botVert = div {className: "board_line board_line_vertical
                               board_line_bottom_vertical"}
    leftHoriz = div {className: "board_line board_line_horizontal"}
    rightHoriz = div {className: "board_line board_line_horizontal
                                  board_line_right_horizontal"}
    handicapPoint = div {className: "handicappoint" }
    blackStone = div {className: "stone black"}
    whiteStone = div {className: "stone white"}
    dame = div {className: "territory neutral"}
    blackScore = div {className: "territory black"}
    whiteScore = div {className: "territory white"}
    blackDead = div {className: "stone black dead"}
    whiteDead = div {className: "stone white dead"}
    lastPlayedMarker = div {className: "last-played"}
    hover = if @props.hoverColor \
            then div {className: "placement #{@props.hoverColor}"} \
            else div {}

    boardDivsForPos = (i, j) ->
      result = []
      if j > 0 then result.push topVert
      if j < size - 1 then result.push botVert
      if i > 0 then result.push leftHoriz
      if i < size - 1 then result.push rightHoriz
      if isHandicapPoint(size, j, i) then result.push handicapPoint
      result

    stoneDivsForPos = (i, j) ->
      color = boardState[j][i]
      result = switch color
        when 'black' then [blackStone]
        when 'white' then [whiteStone]
        when 'empty' then [hover]
        when 'dame' then [dame]
        when 'blackscore' then [blackScore]
        when 'whitescore' then [whiteScore]
        when 'blackdead' then [blackDead, whiteScore]
        when 'whitedead' then [whiteDead, blackScore]
        else []
      if i == lastPlayed.x and j == lastPlayed.y
        result.push lastPlayedMarker
      result

    onClickForPos = (i, j) => (event) =>
      @props.clickCallback {
        x: i
        y: j
      }

    div {className: 'goban'},
        for j in [0...size]
          div {className: 'goban-row'},
              for i in [0...size]
                (div {
                  className: "gopoint row-#{j} col-#{i}"
                  onClick: onClickForPos(i, j)},
                    (boardDivsForPos i, j),
                    (stoneDivsForPos i, j))

NavigationDom = React.createClass
  render: ->
    {sgfObject, viewingMove} = @props

    options = [n: 0, text: 'Start']
    maxMoves = null
    do ->
      moveNo = 0
      for node in sgfObject.gameTrees[0].nodes
        if node.B?
          moveNo += 1
          options.push n: moveNo, text: 'B ' + (a1FromSgfTag(node.B) or 'pass')
        else if node.W?
          moveNo += 1
          options.push n: moveNo, text: 'W ' + (a1FromSgfTag(node.W) or 'pass')
        else if node.TB? or node.TW?
          moveNo += 1
          options.push n: moveNo, text: 'Mark dead'
      maxMoves = moveNo

    reactOption = (option) ->
      {n, text} = option
      React.DOM.option {key: n, value: n},
                       ["Move #{n}: #{text}"]

    onChange = (event) =>
      @props.changeCallback parseInt(event.target.value, 10)

    # hack for Firefox, which won't fire change/input event on
    # keyboard updates to select boxes until the focus is removed
    onKeyUp = (event) ->
      event.target.blur()
      event.target.focus()

    {div, select} = React.DOM
    div {className: 'board_nav_block'},
        (select {
          className: 'move_select',
          onChange: onChange
          onInput: onChange
          onKeyUp: onKeyUp
          value: viewingMove ? maxMoves},
                (reactOption o for o in options))

ScoreDom = React.createClass
  render: ->
    {prisoners, scores} = @props
    {div, span} = React.DOM
    if scores?
      blackScore = div {}, ["Black score: ",
                            span {className: "score black"}, scores.black]
      whiteScore = div {}, ["White score: ",
                            span {className: "score white"}, scores.white]
    else
      blackScore = whiteScore = div {}
    div {className: "score_block"},
        [div {}, ["Black prisoners: ",
                  span {className: "prisoners black"}, prisoners.black],
         div {}, ["White prisoners: ",
                  span {className: "prisoners white"}, prisoners.white],
         blackScore, whiteScore]


# move navigation ====================================================
###

_moveNoListeners = []

exports.onViewMoveNo = (callback) ->
  # _moveNoListeners.push callback
  callback

exports.offViewMoveNo = ->
  "Clear all view move no listeners.

  We need this for testing, where initialise() functions get called in many
  test cases, so we must clean up listeners after each test."
  _moveNoListeners = []

_isViewingLatestMove = false
_viewingMoveNo = 0

exports.isViewingLatestMove = -> _isViewingLatestMove
exports.viewingMoveNo = -> _viewingMoveNo
###

a1FromSgfTag = (tag) ->
  if typeof tag is 'string'
    tag = [tag]
  coordStr = tag[0]
  return '' unless coordStr
  [x, y] = decodeSgfCoord coordStr
  colStr = String.fromCharCode(x + 'a'.charCodeAt(0))
  rowStr = y.toString()
  return "#{colStr}#{rowStr}"

# end of move navigation =============================================

stateFromSgfObject = (sgfObject, options={}) ->
  "Get a board state and associated info from an SGF object.

  If 'moves' is given as an option, include only that many moves.

  If 'scoring' is given as an option, mark dame and scoring points.

  If 'deadStones' is given as an option, the listed stones should be dead."
  {moves, scoring, deadStones} = options
  size = if sgfObject \
         then parseInt(sgfObject.gameTrees[0].nodes[0].SZ, 10) or 19 \
         else 19
  boardState = (('empty' for i in [0...size]) for j in [0...size])
  prisoners = { black: 0, white: 0 }
  moveNo = 0
  for node in sgfObject.gameTrees[0].nodes
    break if moves? and moveNo >= moves
    if node.AB
      coords = if Array.isArray(node.AB) then node.AB else [node.AB]
      for coordStr in coords
        [x, y] = decodeSgfCoord coordStr
        boardState[y][x] = 'black'
    if node.AW
      coords = if Array.isArray(node.AW) then node.AW else [node.AW]
      for coordStr in coords
        [x, y] = decodeSgfCoord coordStr
        boardState[y][x] = 'white'
    if node.B
      moveNo += 1
      [x, y] = decodeSgfCoord node.B
      result = go_rules.getNewStateAndCaptures('black', x, y, boardState)
      boardState = result.state
      prisoners.black += result.captures.black
      prisoners.white += result.captures.white
    if node.W
      moveNo += 1
      [x, y] = decodeSgfCoord node.W
      result = go_rules.getNewStateAndCaptures('white', x, y, boardState)
      boardState = result.state
      prisoners.black += result.captures.black
      prisoners.white += result.captures.white
  if scoring
    [x, y] = [null, null]
    if deadStones?
      for [px, py] in deadStones
        switch boardState[py][px]
          when 'black'
            boardState[py][px] = 'blackdead'
            prisoners.black += 1
          when 'white'
            boardState[py][px] = 'whitedead'
            prisoners.white += 1
    {boardState, prisoners, scores} = scoreState {boardState, prisoners}
  else
    scores = null
  {boardState, lastPlayed: {x, y}, prisoners, scores}

scoreState = (stateObj) ->
  "given a board state, change its 'empty' points to 'blackscore',
  'whitescore' and 'dame' and return it with prisoner counts and total
  scores"
  {boardState, prisoners} = stateObj

  setRegionScores = (region, color) ->
    for [x, y] in region
      if boardState[y][x] == 'empty'
        boardState[y][x] = color

  for region in getEmptyRegions boardState
    boundary = go_rules.boundingColor region, boardState
    setRegionScores region, switch boundary
      when 'black' then 'blackscore'
      when 'white' then 'whitescore'
      when 'neither' then 'dame'
      else throw new Error "invalid boundary color: '#{boundary}'"

  scores = do ->
    black = prisoners.white
    white = prisoners.black
    for row in boardState
      for point in row
        if point == 'blackscore' or point == 'whitedead' then black += 1
        if point == 'whitescore' or point == 'blackdead' then white += 1
    {black, white}

  {boardState, prisoners, scores}

getEmptyRegions = (state) ->
  regions = []
  # which colors count as empty when detecting regions:
  emptyColors = ['empty', 'blackdead', 'whitedead']
  height = state.length
  width = state[0].length
  done = ((false for i in [0..width]) for j in [0..height])
  for rowArray, row in state
    for color, col in rowArray
      continue if done[row][col]
      if state[row][col] in emptyColors
        region = go_rules.groupPoints col, row, state, emptyColors
        for [x, y] in region
          done[y][x] = true
        regions.push region
  return regions

moveCount = (sgfObject) ->
  "Return number of moves (including passes) in sgf object."
  count = 0
  for node in sgfObject.gameTrees[0].nodes
    if node.B or node.W
      count += 1
  count


aCode = 'a'.charCodeAt(0)

exports.decodeSgfCoord = decodeSgfCoord = (coordStr) ->
  x = coordStr.charCodeAt(0) - aCode
  y = coordStr.charCodeAt(1) - aCode
  return [x, y]

exports.encodeSgfCoord = encodeSgfCoord = (x, y) ->
  encodedX = String.fromCharCode(aCode + x)
  encodedY = String.fromCharCode(aCode + y)
  return encodedX + encodedY

cloneSgfObject = (sgfObject) ->
  "The trick here is that 'parent' attributes must be replaced with the parent
  in the new copy instead of pointing to the old one."
  getClone = (v, self, k=null, parent=null) -> switch
    when k == 'parent' then parent
    when Array.isArray v then cloneArrayRecursive v
    when v == Object(v) then cloneObjectRecursive v, self
    else v
  cloneObjectRecursive = (subObject, parent) ->
    result = {}
    for own k, v of subObject
      result[k] = getClone(v, result, k, parent)
    return result
  cloneArrayRecursive = (subArray) ->
    result = []
    for v in subArray
      result.push getClone(v, result)
    return result
  return cloneObjectRecursive sgfObject, null

nextPlayerInSgfObject = (sgfObject) ->
  nodes = sgfObject.gameTrees[0].nodes
  reversedNodes = nodes.slice(0).reverse()  # slice(0) copies
  for node, index in reversedNodes
    if 'B' of node
      return 'white'
    else if 'W' of node
      return 'black'
    else if 'TCRESUME' of node
      # next to move is the first to pass before this resumption
      return _lastPassInRun reversedNodes.slice(index + 1)
  return 'black'

_lastPassInRun = (nodes) ->
  lastPassSeen = null
  for node in nodes
    if 'B' of node
      if node.B == null or node.B == ''
        lastPassSeen = 'black'
      else
        break
    else if 'W' of node
      if node.W == null or node.W == ''
        lastPassSeen = 'white'
      else
        break
    else
      break
  if lastPassSeen == null
    throw Error "no passes found before resumption node"
  return lastPassSeen

isPassedTwice = (sgfObject) ->
  # true iff sgf ends with two successive passes
  nodes = sgfObject.gameTrees[0].nodes
  len = nodes.length
  isPass = (node) -> node.B == '' or node.W == ''
  return len >= 2 and isPass(nodes[len-1]) and isPass(nodes[len-2])

sgfObjectWithMoveAdded = (sgfObject, color=null, col=null, row=null) ->
  if col != null and row != null
    coordStr = encodeSgfCoord col, row
  else
    coordStr = ''

  if color == null
    color = nextPlayerInSgfObject sgfObject
  sgfTag = switch color
    when 'black' then 'B'
    when 'white' then 'W'
    else throw Error "invalid new stone color"

  newMove = {}
  newMove[sgfTag] = coordStr

  sgfObjectCopy = cloneSgfObject sgfObject
  nodes = sgfObjectCopy.gameTrees[0].nodes
  if nodes.length == 1 and jQuery.isEmptyObject nodes[0]
    nodes[0] = newMove
  else
    nodes.push newMove

  return sgfObjectCopy

# markStonesAround and helpers

getNewDeadForToggledPoint = (state, x, y) ->
  "Return the new set of dead stones resulting from toggling the
  life/death status of the stone at (x, y) and all friendly stones in
  the region (ie. the area bounded by unfriendly stones).  If killing
  stones, also revive surrounding enemy stones.

  Changes `state` as a side effect (at time of writing this doesn't
  matter for our callers)."
  markStonesAround state, x, y
  dead = []
  for row, j in state
    for point, i in row
      if point == 'blackdead' or point == 'whitedead'
        dead.push [i, j]
  dead

markStonesAround = (state, x, y) ->
  "Toggle the life/death status of the given point and all friendly stones in
  the region (ie. the area bounded by unfriendly stones).  If killing stones,
  also revive surrounding enemy stones."
  color = state[y][x]
  return if color == 'empty'
  isKilling = color in ['black', 'white']
  # we're assuming here that the region never contains both live and dead
  # stones of the same color, as the interface should not allow this to happen
  region = go_rules.groupPoints(
    x, y, state,
    # list of colors to include in 'group'
    ['empty', 'dame', 'blackscore', 'whitescore', color])
  togglePoints state, region
  if isKilling
    reviveAroundRegion state, region
  return

reviveAroundRegion = (state, region) ->
  "Revive all dead groups touching, but not in, the given region; together with
  friendly stones in their own regions."
  height = state.length
  width = state[0].length
  ignore = ((false for i in [0..width]) for j in [0..height])
  for [x, y] in region
    ignore[y][x] = true

  for [x, y] in region
    for [xn, yn] in go_rules.neighboringPoints x, y, state
      continue if ignore[yn][xn]
      ignore[yn][xn] = true
      neighborColor = state[yn][xn]
      if neighborColor in ['blackdead', 'whitedead']
        neighborRegion = go_rules.groupPoints(
          xn, yn, state,
          # list of colors to include in 'group'
          ['empty', 'dame', 'blackscore', 'whitescore', neighborColor])
        togglePoints state, neighborRegion
        for [xg, yg] in neighborRegion
          ignore[yg][xg] = true
  return

togglePoints = (state, points) ->
  "Among the given points, mark live stones as dead and dead stones as alive."
  for [x, y] in points
    color = state[y][x]
    continue if color == 'empty'
    newColor = switch color
      when 'black' then 'blackdead'
      when 'white' then 'whitedead'
      when 'blackdead' then 'black'
      when 'whitedead' then 'white'
      else null
    if newColor
      state[y][x] = newColor
  return

# end markStonesAround
